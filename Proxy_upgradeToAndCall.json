{
  "target": [
    {
      "filename": "ex.sol",
      "contract": "BaseAdminUpgradeabilityProxy",
      "fname": "upgradeToAndCall"
    }
  ],
  "similarity": [
    {
      "vulneability_type": "re-entrancy",
      "severity": "high",
      "path": "lending/Akropolis.sol",
      "code": "```solidity\npragma solidity ^0.5.0;\n\ncontract Proxy {\n\n  function () payable external {\n    _fallback();\n  }\n\n  function _implementation() internal view returns (address);\n\n  function _delegate(address implementation) internal {\n    assembly {\n\n      calldatacopy(0, 0, calldatasize)\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  function _willFallback() internal {\n  }\n\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n\n\npragma solidity ^0.5.0;\n\nlibrary OpenZeppelinUpgradesAddress {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\npragma solidity ^0.5.0;\n\ncontract BaseUpgradeabilityProxy is Proxy {\n\n  event Upgraded(address indexed implementation);\n\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  function _implementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n\n\npragma solidity ^0.5.0;\n\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}\n\npragma solidity ^0.5.0;\n\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n\npragma solidity ^0.5.0;\n\n\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n}```",
      "contract": "BaseAdminUpgradeabilityProxy",
      "function": "upgradeToAndCall",
      "score": 1.0,
      "etherscan": "https://etherscan.io/address/0x73fC3038B4cD8FfD07482b92a52Ea806505e5748#code",
      "description": "## Reentrancy \n\n ### Definition : \n- Reentrancy is a vulnerability that allows a function to repeatedly call another function within a contract before completing the previous execution.\n- This typically occurs when an internal contract calls an external contract. \n\n ### example : \n- When contract A calls contract B, B's code is executed.\n- If contract B then calls a function within contract A, it permits reentry, potentially leading to changes in A's state.\n- Reentrancy is particularly risky in financial operations.\n- If contract A sends ether to contract B and B subsequently calls a function in A to return the ether, A may process the funds within B's function, creating an opportunity for an attacker to repeatedly siphon off ether.\n\n### Prevention :\n- To prevent Reentrancy vulnerabilities, it's essential to modify the state before making external calls or employ locking mechanisms when necessary to thwart attacks and enhance security."
    }
  ]
}
